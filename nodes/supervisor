#!/usr/bin/env python
# -*- coding: UTF-8 -*-

import logging
logging.basicConfig(level=logging.DEBUG)

from itertools import imap
from flup.server.fcgi import WSGIServer
import urlparse
from jinja2 import Environment, PackageLoader

import threading
import os
import traceback

import datetime
import time

import json

import subprocess


from freeplay_sandbox_supervisor.launcher import Launcher

ROOT = "/home/skadge/src/engagement_architecture"

launchers = []
records = {}

for root, dirs, files in os.walk(ROOT):
    for file in files:
        if file.endswith(".py"):
            logging.info("Loading script %s" % file)
            launchers.append(Launcher(os.path.join(root, file), ROOT))


logging.info("Loading the HTML templates...")
env = Environment(loader=PackageLoader('freeplay_sandbox_supervisor', 'tpl'))
supervisor_tpl = env.get_template('supervisor.tpl')
launcher_tpl = env.get_template('launcher.tpl')

def fixencoding(s):
    return s.encode("utf-8")

def getfreespace(path="/"):
    df = subprocess.Popen(["df", "-h", path], stdout=subprocess.PIPE)
    output = df.communicate()[0]
    device, size, used, available, percent, mountpoint = output.split("\n")[1].split()
    return "available space on hard-drive: %s/%s (%s%%)" % (available, size, 100-int(percent[:-1]))

def getlauncher(name):
    launcher = None
    for l in launchers:
        if l.name == name:
            launcher = l
            break
    return launcher

def process_launch(options):
    launchfile = options["launch"][0]

    launcher = getlauncher(launchfile)
    if launcher is None:
        logging.warn("Attempting to launch inexistant %s" % launchfile)
        return False

    env = dict(os.environ)

    if "start" in options["action"]:
        launcher.start(env=env)
    elif "stop" in options["action"]:
        launcher.shutdown()

    return "true" if launcher.isrunning() else "false"

def process(path, options):

    try:
        if "action" in options:
            ############################################
            # status
            ############################################
            if "start" in options["action"]:
                return process_launch(options)

            elif "stop" in options["action"]:
                return process_launch(options)

            elif "setarg" in options["action"]:
                launcher = getlauncher(options["launch"][0])
                launcher.setarg(options["arg"][0],
                                options.get("value", [None])[0])
                return launcher_tpl.generate(launcher=launcher, showargs=True)

            elif "updatestate" in options["action"]:
                return json.dumps({l.name: l.isrunning() for l in launchers})


            ############################################
            # records
            ############################################
#            elif "start_sandbox" in options["action"]:
#                launcher = getlauncher("interactive_playground")
#                launcher.start()
#                return "true"
#
#            elif "start_cameras" in options["action"]:
#                launcher = getlauncher("dual_sr300")
#                launcher.start()
#                return "true"
#
#            elif "start_attention_tracking" in options["action"]:
#                launcher = getlauncher("dual_attention_tracking")
#                launcher.start()
#                return "true"
#
#            elif "initiate_experiment" in options["action"]:
#
#                # first, stop all ROS nodes, so that we properly restart them with
#                # logging configured for storage within the next experiment folder.
#                for launcher in launchers:
#                    launcher.shutdown()
#
#                logging.info("Creating new experiment")
#                expe = Experiment(options["cdt"][0])
#                records[repr(expe)] = expe
#                logging.info("Experiment %s created" % expe)
#                return json.dumps([repr(expe), expe.purple.id, expe.yellow.id])
#
#            elif "savedemographics" in options["action"]:
#                logging.info("Saving demographics")
#                expe.save_demographics(options)
#                return json.dumps(True)
#
#            elif "getdetectedfaces" in options["action"]:
#                return json.dumps({"yellow": nb_yellow_faces, "purple": nb_purple_faces})
#
#
#            elif "start_visual_tracking" in options["action"]:
#                logging.info("Starting the visual tracking task")
#
#                launcher = getlauncher("record_visual_tracking")
#                launcher.setarg("output_file", os.path.join(expe.path, "visual_tracking.bag"))
#                launcher.setarg("duration", "45") # seconds
#                launcher.start()
#
#                visual_tracking_publisher.publish(Empty())
#
#                cv_visual_tracking_ended.acquire()
#                cv_visual_tracking_ended.wait()
#                cv_visual_tracking_ended.release()
#
#
#                launcher.shutdown()
#
#                launcher = getlauncher("dual_sr300")
#                launcher.shutdown()
#
#                logging.info("Visual tracking task finished")
#                return 'true'
#
#            elif "start_items_placement" in options["action"]:
#                logging.info("Starting the items placement task")
#
#                launcher = getlauncher("dual_sr300")
#                launcher.shutdown()
#
#                if(expe.condition == CHILDROBOT):
#                    logging.info("Starting the robot first in Wizard-of-Oz mode")
#                    robot_launcher = getlauncher("woz")
#                    robotip = options['robot-ip'][0];
#                    logging.info("Setting the robot IP address to %s" % robotip)
#                    robot_launcher.setarg("nao_ip", robotip)
#                    robot_launcher.setarg("with_robot", True)
#                    robot_launcher.setarg("arm_reach", 0.5)
#
#                    ##### WORKAROUND FOR NAOQI MESSING UP WITH THE ENVIRONMENT
#                    # in general, we does not want the naoqi SDK to appear in the
#                    # LD_LIBRARY_PATH as it contains old libraries. But when launching
#                    # the robot, this needs to be added
#                    env = dict(os.environ)
#                    env['LD_LIBRARY_PATH'] = env['LD_LIBRARY_PATH'] + ":" + env['HOME'] + "/nao/naoqi-sdk-2.1.4.13-linux64/lib"
#                    ######
#
#                    robot_launcher.start(env=env)
#
#                prepare_launcher = getlauncher("prepare_recording")
#                prepare_launcher.start()
#
#                launcher = getlauncher("record_items_placement")
#                launcher.setarg("output_file", os.path.join(expe.path, "items_placement.bag"))
#                launcher.setarg("duration", "15m")
#                launcher.start()
#
#                items_placement_publisher.publish(Empty())
#                return 'true'
#
#            elif "stop_items_placement" in options["action"]:
#                logging.info("Stopping items placement")
#
#                record_launcher = getlauncher("record_items_placement")
#                record_launcher.shutdown()
#
#                prepare_launcher = getlauncher("prepare_recording")
#                prepare_launcher.shutdown()
#
#                return 'true'
#
#            elif "start_freeplay" in options["action"]:
#                logging.info("Starting freeplay task")
#
#                # if the cameras are still running (eg, visual tracking as been skipped), stop them now
#                launcher = getlauncher("dual_sr300")
#                launcher.shutdown()
#
#                prepare_launcher = getlauncher("prepare_recording")
#                prepare_launcher.shutdown()
#                #######################################################
#
#                freeplay_publisher.publish(Empty())
#
#                if(expe.condition == CHILDROBOT):
#                    logging.info("Starting the robot first")
#                    robot_launcher = getlauncher("play")
#                    robotip = options['robot-ip'][0];
#                    logging.info("Setting the robot IP address to %s" % robotip)
#                    robot_launcher.setarg("nao_ip", robotip)
#                    robot_launcher.setarg("with_robot", True)
#                    robot_launcher.setarg("arm_reach", 0.5)
#
#                    ##### WORKAROUND FOR NAOQI MESSING UP WITH THE ENVIRONMENT
#                    # in general, we does not want the naoqi SDK to appear in the
#                    # LD_LIBRARY_PATH as it contains old libraries. But when launching
#                    # the robot, this needs to be added
#                    env = dict(os.environ)
#                    env['LD_LIBRARY_PATH'] = env['LD_LIBRARY_PATH'] + ":" + env['HOME'] + "/nao/naoqi-sdk-2.1.4.13-linux64/lib"
#                    ######
#
#                    robot_launcher.start(env=env)
#
#                prepare_launcher = getlauncher("prepare_recording")
#                prepare_launcher.start()
#                record_launcher = getlauncher("record")
#                record_launcher.setarg("output_file", os.path.join(expe.path, "freeplay.bag"))
#                record_launcher.setarg("duration", "40m")
#                record_launcher.start()
#                time.sleep(2)
#
#                expe.start()
#
#                return 'true'
#
#            elif "stop_freeplay" in options["action"]:
#                logging.info("Stopping freeplay task")
#
#                blankscreen_publisher.publish(Empty())
#
#                robot_launcher = getlauncher("play")
#                robot_launcher.shutdown()
#
#                record_launcher = getlauncher("record")
#                record_launcher.shutdown()
#                prepare_launcher = getlauncher("prepare_recording")
#                prepare_launcher.shutdown()
#
#                return 'true'
#
#            elif "add_marker" in options["action"]:
#                mtype = options["type"][0]
#
#                mtime = expe.add_marker(mtype)
#                logging.info("Adding marker at t=%s secs (%s)" % (mtime, mtype))
#
#                return mtime
#
#            elif "add_extra" in options["action"]:
#                key = options["name"][0]
#                value = options["value"][0]
#
#                expe.add_extra(key, value)
#                logging.info("Adding extra information: %s -> %s" % (key, value))
#
#                return 'true'
#
            elif "finalise" in options["action"]:
                logging.info("Finalising the experiment")

                for launcher in launchers:
                    launcher.shutdown()
                logging.info("All scripts stopped!")

                return 'true'


            else: 
                logging.warn("record: received unknown action %s" % str(options["action"]))
                return 'false'

    except Exception as e:
        logging.error("Error processing the request! (%s %s)" % (path, str(options)))
        logging.error(traceback.format_exc())

    return supervisor_tpl.generate(path=path,
                                   freespace=getfreespace(),
                                   launchers=launchers,
                                   nodes_ok=[], 
                                   nodes_ko=[])

def app(environ, start_response):

    start_response('200 OK', [('Content-Type', 'text/html')])

    path = environ["PATH_INFO"].decode("utf-8")

    options = urlparse.parse_qs(environ["QUERY_STRING"])
    logging.debug("Incoming request. Path: %s; options passed:\n%s" % (path, str(options)))

    return imap(fixencoding, process(path,options))

if __name__ == '__main__': 

    IP="127.0.0.1"
    PORT=8080

    logging.info("Starting the CGI server on %s:%d (you still need a webserver, though!)" % (IP, PORT))

    WSGIServer(app, bindAddress = (IP, PORT)).run()

    for launcher in launchers:
        launcher.shutdown()

    logging.info("Bye bye.")

